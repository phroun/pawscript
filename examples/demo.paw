# PawScript Syntax Demonstration
# This file showcases all the major syntax features of PawScript

# ==========================================
# COMMENTS
# ==========================================

# Line comments start with # (when followed by whitespace or end of line)
echo "Line comments work"  # This is also a comment

#( Block comments can span
   multiple lines and use
   parentheses )#

#{ Alternative block comment style
   using braces instead }#

# Comments can contain special characters: !@#$%^&*()
# Comments can contain unicode: ðŸŽ‰ Ã©mojis and accÃ©nts

#{ This comment can contain don't, can't, won't, and other contractions }#

#{ Comments can say "you can mention ')#' inside double quotes" without closing }#

#( Same rules apply: don't worry about single quotes here )#

#( But you can still mention "nested )# symbols" in double quotes )#

echo "Comments testing complete."

# ==========================================
# BASIC COMMANDS
# ==========================================

# Simple commands with no arguments
true
false

# Commands with arguments (comma-separated)
echo "Hello, World!"
echo "Multiple", "arguments", "here"

# Commands with different argument types
echo 42                    # Numbers
echo true                  # Booleans  
echo "quoted string"       # Strings
echo 'single quotes work'  # Single quotes
echo "Should see 42, true, "quoted string" and 'single quotes work', with no quotes."

echo "Basic commands testing complete."

# ==========================================
# COMMAND SEPARATORS & FLOW CONTROL
# ==========================================

# Semicolon separator - always execute next command
write "First"; write "Second"; write "Third"
print
echo "FirstSecondThird = Good"

# Newlines act as semicolons
write "First"
write "Second" 
write "Third"
print
echo "FirstSecondThird = Good"

# AND operator (&) - execute next only if current succeeds
true & echo "This runs because true succeeded"
false & echo "This won't run because false failed"

# OR operator (|) - execute next only if current fails  
true | echo "This won't run because true succeeded"
false | echo "This runs because false failed"

# Complex flow control chains
true & echo "Step 1" & echo "Step 2" | echo "Fallback"
echo "Should see above: 'This runs', 'This runs', and 'Step 1', 'Step 2'"

# Multi-line flow control
true &
echo "This continues from previous line" &
echo "And this continues too"
echo "Should see 'This continues...' and '...too'"

false |
echo "This runs because false failed" |
echo "This won't run because previous succeeded"
echo "Should only see 'This runs because false failed'"

echo "Chaining test complete."

# ==========================================
# PARENTHESES (Argument Grouping)
# ==========================================

# Parentheses group content into single arguments
echo (This entire phrase becomes one argument)
echo "This entire phrase becomes one argument = Good"
echo (Complex argument with; semicolons & operators | inside)
echo "Complex argument with; semicolons & operators | inside = Good"

# Mixed parentheses and quotes
write "String argument", (grouped argument), 42, "\n"
echo "String argumentgrouped argument42 = Good"

# Nested parentheses
echo (Outer (inner content) more outer)
echo "Outer (inner content) more outer = Good"

echo "Parenthesis test compmlete."

# ==========================================
# BRACES (Execution Blocks)
# ==========================================

# Braces execute commands and substitute the result
echo "The result is: {write calculated}"
echo "calculatedThe result is: true = Good for side-effect printing."
echo "The result is: calculated = Good for captured printing."

# Braces can contain complex command sequences
echo "Answer: {true & write 42 | write unknown}"
echo "42Answer: = Good for side-effect printing."
echo "Answer: 42 = Good for captured printing."

# Nested braces
echo "Nested: {write {write inner}}"
echo "innertrueNested: = Good for side-effect printing."
echo "Nested: inner = Good for captured printing."

# Braces in string concatenation
echo "prefix{set_result middle}suffix"
echo "prefixmiddlesuffix = Good"

# Multiple braces in one argument
echo "{set_result Hello} {set_result World}"
echo "Hello World = Good"

echo "Braces testing complete."

# ==========================================
# MACROS
# ==========================================

echo "Defining macros."

# Define a simple macro
macro "greet", (echo "Hello $1!")

macro "define_macros", (
    # Define a macro with multiple commands
    macro "greet_formal", (
        write "Good day, $1.";
        echo "How are you today?"
    )

    # Define a macro with argument substitution patterns
    macro "describe_args", (
        write "You provided $# arguments: $*; ";
        write "First argument: $1; ";
        echo "Second argument: $2"
    )

    # Define a macro with conditional logic
    macro "safe_greet", (
        macro "stow_away", (
            echo "This will not be called, but is checking nesting."
        )
        echo "Checking name..." &
        echo "Hello $1!" |
        echo "Hello there!"
    )
)

define_macros

echo "Nothing should have printed yet after definition of macros."

# Execute macros
greet "Alice"
echo "Hello Alice! = Good"
greet_formal "Bob" 
echo "Good day, Bob.How are you today? = Good"
describe_args "one", "two", "three"
echo "You provided 3 arguments: one, two, three; First argument: one; Second argument: two = Good"

# Execute macros using call command
call greet, "Charlie"
echo "Hello, Charlie! = Good"
call describe_args, "alpha", "beta"
echo "You provided 2 arguments: alpha, beta; First argument: alpha; Second argument: beta = Good"

# Macros with brace expressions
macro smart_echo(echo "Smart: {set_result $1}")
smart_echo "test"
echo "Smart: test = Good"

echo "Macro test complete."

# ==========================================
# SYNTACTIC SUGAR
# ==========================================

# Identifier-parentheses syntax for macro definition
macro quickGreet(echo "Quick hello to $1!")

# This is equivalent to:
# macro "quickGreet", (echo "Quick hello to $1!")

quickGreet "Eva"
echo "Quick hello to Eva! = Good"

# ==========================================
# COMPLEX COMBINATIONS
# ==========================================

# Macros calling other macros
macro chain_greet(greet $1; echo "That was a greeting for $1")
chain_greet "David"
echo 'Above should have shown "Hello David!" and "That was a greeting for David"'

# Braces with macro calls
echo "Macro result: {greet_formal Edgar}"
echo "Good day, Edgar.How are you today?\nMacro result: true = Good for side effect."
echo "Macro result: Good day, Edgar.How are you today? = Good for capture."

# Flow control with braces
true & echo "Success: {set_result computed}" | echo "Failed"
echo "Success: computed = Good"

# Complex argument mixing
echo "Mixed args:", (grouped text), "string", 42, {set_result dynamic}
echo "Mixed args: grouped text string 42 dynamic = Good"

print
write "Defining complex_demo..."

# Multi-line macro with complex flow
macro complex_demo(
    echo "Starting complex demo for $1";
    true & (
        echo "Phase 1 complete" &
        echo "Phase 2 starting" &
        echo "Result: {set_result $1 processed}"
    ) | echo "Something went wrong";
    echo "Demo complete"
)

echo "done."
echo "Calling complex_demo:"

complex_demo "test-data"

echo "Done with complex_demo."

# ==========================================
# NESTED STRUCTURES
# ==========================================

# Deeply nested parentheses
echo (Level 1 (Level 2 (Level 3) back to 2) back to 1)
echo "Level 1 (Level 2 (Level 3) back to 2) back to 1 = Good"

# Mixed nesting
echo "Text", (grouped (nested) text), {set_result "dynamic {set_result nested}"}, "more"
echo "Text grouped (nested) text dynamic nested more = Good"

# Complex macro with everything
macro kitchen_sink(
    # This macro demonstrates multiple features
    echo "=== Kitchen Sink Demo for $1 ===";
    
    # Conditional execution
    true & echo "Condition passed" | echo "Condition failed";
    
    # Brace expressions with the argument
    echo "Processed: {echo $1 | echo unknown}";
    
    # Nested execution
    echo "Nested result: {
        echo "Inner: $1" &
        echo "Success!" |
        echo "Failed!"
    }";
    
    # Multiple argument patterns
    echo "Args: $# total, all: $*, first: $1";
    
    echo "=== End Kitchen Sink ==="
)

# Execute the complex macro
kitchen_sink "final-test"

echo "End nested structures test."

# ==========================================
# PRACTICAL EXAMPLES
# ==========================================

# Error handling pattern
macro safe_operation(
    echo "Attempting operation..." &
    true & echo "Operation succeeded" |  
    echo "Operation failed, trying fallback" &
    echo "Fallback complete"
)

# Conditional greeting based on time (hypothetical)
macro time_greet(
    echo "Good morning $1" |
    echo "Good evening $1"
)

# Validation pattern
macro validate_and_process(
    echo "Validating $1..." &
    true & (
        echo "Validation passed" &
        echo "Processing $1..." &
        echo "Result: {echo $1 processed}"
    ) | (
        echo "Validation failed for $1" &
        echo "Using default processing"
    )
)

validate_and_process "user-input"

echo "End practical examples."

# ==========================================
# EDGE CASES & SPECIAL CHARACTERS
# ==========================================

# Strings with special characters
echo "String with & and | and ; inside"
echo "String with X and Y and Z inside = Good"
echo 'Single quotes with & | ; too'
echo "Single quotes with X Y Z too = Good"

# Arguments with operators (inside parentheses)
echo (This argument has & and | operators)
echo "This argument has X and Y operators = Good"

# Unicode and special characters
echo "Unicode test: ðŸŽ‰ Hello ä¸–ç•Œ cafÃ©"
echo "Unicode test: Party  Hello chinese cafe = Good"

# Escaped characters in strings
echo "Escaped quotes: \"Hello\" and 'World'"
echo "Escaped quotes: ^Hello^ and ^World^ = Good"
echo "Newlines: line1\nline2\ttabbed"
echo "Newlines: line1, line2 ---> tabbed = Good"

# Empty arguments and edge cases
echo "", "non-empty", "", (), "token"
echo " non-empty   token = Good"
echo (empty parentheses become empty string)

# Comments don't interfere with parsing
echo "test" # comment & with | operators; and semicolons
echo "test = Good"
echo (grouped #{ comment in group }# text)
echo "grouped  text = Good"

echo "End edge cases."

# ==========================================
# MACRO MANAGEMENT
# ==========================================

echo "Print macro list:"

# List all defined macros
macro_list

echo "End macro list."

# Delete a specific macro
macro_delete "old_macro"

# Clear all macros (commented out to preserve our demos)
# macro_clear

echo "=== PawScript Syntax Demo Complete ==="

   check_line_and_col_of_error_389_4