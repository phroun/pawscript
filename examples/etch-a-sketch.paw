// Etch-A-Sketch Demo
// Use WASD to move the @ symbol around the screen
// Press SPACE to change the trail color
// An enemy (X) wanders around erasing your work!
// Press Q to quit

// Initialize keyboard input
channels: {readkey_init}
#lines: {argv ~channels, 1}
#keys: {argv ~channels, 2}

// Get screen dimensions
info: {cursor}
screenRows: {ret ~info.screen_rows}
screenCols: {ret ~info.screen_cols}

// Calculate playable area (leave room for status line at top)
playTop: 2
playBottom: {sub ~screenRows, 1}
playLeft: 1
playRight: {sub ~screenCols, 1}

// Player position (start in center)
playerX: {div ~screenCols, 2}
playerY: {div ~screenRows, 2}

// Enemy position (start in corner)
enemyX: 5
enemyY: 5

// Current trail color
trailColor: "green"

// Track if we're in color input mode
inColorMode: false

// Game state
running: true
lastEnemyMove: 0
enemyMoveInterval: 500

// Helper macro to draw at position
macro drawAt (x, y, char, fg) (
    cursor ~x, ~y
    color ~fg
    write "~char"
    color reset: true
)

// Helper macro to move cursor and get input
macro clearStatusLine () (
    cursor 1, 1
    clear line
)

// Helper to clamp position
macro clamp (val, minVal, maxVal) (
    result: ~val
    if (lt ~result, ~minVal), (result: ~minVal)
    if (gt ~result, ~maxVal), (result: ~maxVal)
    ret ~result
)

// Clear screen and draw initial state
clear screen
cursor visible: false

// Draw border hint
cursor 1, 1
color cyan
write "WASD=move  SPACE=color  Q=quit | Trail color: ~trailColor"
color reset: true

// Draw player
drawAt ~playerX, ~playerY, "@", white

// Draw enemy
drawAt ~enemyX, ~enemyY, "X", red

// Track time for enemy movement
tickCount: 0

// Main game loop
while ~running (
    // Check for key input (non-blocking by checking length first)
    hasKey: {gt {len ~#keys}, 0}

    if ~hasKey (
        key: {readkey}

        // Store old position to draw trail
        oldX: ~playerX
        oldY: ~playerY

        // Handle movement
        if (eq ~key, "w"), (playerY: {sub ~playerY, 1})
        if (eq ~key, "W"), (playerY: {sub ~playerY, 1})
        if (eq ~key, "s"), (playerY: {add ~playerY, 1})
        if (eq ~key, "S"), (playerY: {add ~playerY, 1})
        if (eq ~key, "a"), (playerX: {sub ~playerX, 1})
        if (eq ~key, "A"), (playerX: {sub ~playerX, 1})
        if (eq ~key, "d"), (playerX: {add ~playerX, 1})
        if (eq ~key, "D"), (playerX: {add ~playerX, 1})

        // Handle quit
        if (eq ~key, "q"), (running: false)
        if (eq ~key, "Q"), (running: false)

        // Handle color change
        if (eq ~key, " "), (
            inColorMode: true

            // Show color prompt on status line
            clearStatusLine
            color yellow
            write "Enter color name: "
            color reset: true

            // Read a line of input (blocking)
            newColor: {read ~#lines}

            // Update color if not empty
            if (gt {len ~newColor}, 0), (
                trailColor: ~newColor
            )

            // Restore status line
            clearStatusLine
            color cyan
            write "WASD=move  SPACE=color  Q=quit | Trail color: ~trailColor"
            color reset: true

            inColorMode: false
        )

        // Clamp player position
        playerX: {clamp ~playerX, ~playLeft, ~playRight}
        playerY: {clamp ~playerY, ~playTop, ~playBottom}

        // Draw trail at old position (if moved)
        moved: false
        if (ne ~oldX, ~playerX), (moved: true)
        if (ne ~oldY, ~playerY), (moved: true)

        if ~moved (
            drawAt ~oldX, ~oldY, ".", ~trailColor
        )

        // Draw player at new position
        drawAt ~playerX, ~playerY, "@", white
    )

    // Enemy movement (only if not in color mode)
    if (not ~inColorMode) (
        tickCount: {add ~tickCount, 1}

        // Move enemy every ~10 ticks (500ms / 50ms per tick)
        if (ge ~tickCount, 10) (
            tickCount: 0

            // Save old enemy position
            oldEnemyX: ~enemyX
            oldEnemyY: ~enemyY

            // Random movement (0-3: up, down, left, right)
            direction: {random 0, 3}

            if (eq ~direction, 0), (enemyY: {sub ~enemyY, 1})
            if (eq ~direction, 1), (enemyY: {add ~enemyY, 1})
            if (eq ~direction, 2), (enemyX: {sub ~enemyX, 1})
            if (eq ~direction, 3), (enemyX: {add ~enemyX, 1})

            // Clamp enemy position
            enemyX: {clamp ~enemyX, ~playLeft, ~playRight}
            enemyY: {clamp ~enemyY, ~playTop, ~playBottom}

            // Erase old enemy position (erasing trail too!)
            drawAt ~oldEnemyX, ~oldEnemyY, " ", white

            // Draw enemy at new position
            drawAt ~enemyX, ~enemyY, "X", red

            // Redraw player in case enemy walked over them
            drawAt ~playerX, ~playerY, "@", white
        )
    )

    // Small delay to prevent CPU spinning
    msleep 50
)

// Cleanup
cursor visible: true
cursor 1, ~screenRows
color reset: true
print ""
print "Thanks for playing!"

readkey_stop
