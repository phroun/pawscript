keycats: {list (note: "Unshifted basic keys - including space",
    ("Escape","`","1","2","3","4","5","6","7","8","9","0","-","=","Backspace"),
    ("Tab","q","w","e","r","t","y","u","i","o","p","[","]","\\"),
    ("a","s","d","f","g","h","j","k","l",";","'","Enter"),
    ("z","x","c","v","b","n","m",",",".","/"),
    (" "),
  ), (note: "Shifted basic keys",
    ("S-Escape", "~", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "_", "+", "S-Backspace"),
    ("S-Tab", "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", "{", "}", "|"),
    ("A", "S", "D", "F", "G", "H", "J", "K", "L", ";", "\"", "S-Enter"),
    ("Z", "X", "C", "V", "B", "N", "M", "<", ">", "?")
  )}


macro testcat(
  l: $1
  bag: {list}
  for ~l, k, index: i, (
    for ~k, r, index: j, (
      bag: {concat ~bag, {list {ret "~i;_~j"}: ~r}}
    )
  )
  
  while (gt {maplen ~bag}, 0), (
    
    print ~l.note, "\r\n"
    
    lr: ""
    for ~bag, k, v, (
      pr: {split ~k, "_"}
      if {neqs ~pr 0, "~lr"} then (
        lr: ~pr 0
      )
      color 1
      write "[", ~k, "]"
      color 15
      write ~v, "  "
      color -1
    )
    
    print "\r\n"
    write "Type each character: "
    ch: {readkey}
    
    if {eq ~ch, "Escape"} then (
      write "\r\n\r\nTYPE \"NEXT\" TO END CATEGORY, TYPE \"QUIT\" TO END TEST: "
      cmd: {trim {lower {read}}}
      if {eq ~cmd, "quit"} then (
        ret {list "quit", ~bag}
      )
      if {eq ~cmd, "next"} then (
        ret {list "next", ~bag}
      )
      
    )
    
    print "\r\n"
    
    print {type ch}

    for ~l, v, index: i, (
      idx: {index ~v ~i, "~ch"}
      if {gte ~idx, 0} then (
        subj: {concat ~i, "_", ~idx}
        print "replacing:", ~subj, ":::"
        bag: {replace ~bag, ~subj: undefined}
        print "index: ", ~i, ~idx, "\r\n"
      )
    )
    print

  )
  
  ret {list "done"}
)


echo ~#args.os ~args.arch

readkey_init #in, echo: #out

testnum: 0
res: true
while (true), (
  (reason, remain): {testcat ~keycats ~testnum}
  print "REASON=", ~reason
  print "REMAIN=", ~remain
  if {eq ~reason, "quit"}
  then (
    print "MATCH FOUND"
    res: false
  )
  else
  ret "dead"
  if {contains ("next","done"),  ~reason}
  then (
    testnum: {add ~testnum, 1}
  )
)
print "done"

readkey_stop
