# Test generator and iterator functionality

print "=== Test 1: Simple generator with sequential yields ==="
macro simple_gen (
    yield "first"
    yield "second"
    yield "third"
    ret "done"
)

gen: {generator simple_gen}
print "Created generator"
print "v1:", {resume ~gen}
print "v2:", {resume ~gen}
print "v3:", {resume ~gen}
print "v4:", {resume ~gen}
print "Token valid:", {token_valid ~gen}
print ""

print "=== Test 2: Generator with while loop ==="
macro counter (
    i: $1
    max: $2
    while (lt ~i, ~max), (
        yield ~i
        i: {add ~i, 1}
    )
    ret "finished"
)

gen2: {generator counter, 1, 4}
print "Count 1-3:"
print " ", {resume ~gen2}
print " ", {resume ~gen2}
print " ", {resume ~gen2}
print "Final:", {resume ~gen2}
print ""

print "=== Test 3: Fibonacci generator ==="
macro fib_gen (
    count: $1
    a: 0
    b: 1
    i: 0
    while (lt ~i, ~count), (
        yield ~a
        temp: ~b
        b: {add ~a, ~b}
        a: ~temp
        i: {add ~i, 1}
    )
    ret "end"
)

fib: {generator fib_gen, 8}
print "First 8 Fibonacci numbers:"
print {resume ~fib}, {resume ~fib}, {resume ~fib}, {resume ~fib}, {resume ~fib}, {resume ~fib}, {resume ~fib}, {resume ~fib}
print "After exhaustion:", {resume ~fib}
print ""

print "=== Test 4: Generator with computation ==="
macro squares_gen (
    n: $1
    i: 1
    limit: {add ~n, 1}
    while (lt ~i, ~limit), (
        sq: {mul ~i, ~i}
        yield ~sq
        i: {add ~i, 1}
    )
    ret "done"
)

sq: {generator squares_gen, 4}
print "Squares 1-4:", {resume ~sq}, {resume ~sq}, {resume ~sq}, {resume ~sq}
print ""

print "=== Test 5: each iterator ==="
fruits: {list "apple", "banana", "cherry"}
iter: {each ~fruits}
print "Iterating fruits:"
print " -", {resume ~iter}
print " -", {resume ~iter}
print " -", {resume ~iter}
print "After list:", {resume ~iter}
print "Token valid:", {token_valid ~iter}
print ""

print "=== Test 6: pair iterator ==="
config: {list host: "localhost", port: 8080}
piter: {pair ~config}
print "Config pairs:"
p1: {resume ~piter}
print " ", {argv ~p1, 1}, "=", {argv ~p1, 2}
p2: {resume ~piter}
print " ", {argv ~p2, 1}, "=", {argv ~p2, 2}
print "After pairs:", {resume ~piter}
print "Token valid:", {token_valid ~piter}
print ""

print "=== Test 7: Nested each iterators ==="
matrix: {list {list 1, 2}, {list 3, 4}}
print "Matrix values:"
outer: {each ~matrix}
row: {resume ~outer}
inner: {each ~row}
print " ", {resume ~inner}, {resume ~inner}
row: {resume ~outer}
inner: {each ~row}
print " ", {resume ~inner}, {resume ~inner}
print ""

print "=== Test 8: each with empty list ==="
empty: {list}
e_iter: {each ~empty}
print "Empty iterator result:", ~e_iter
print ""

print "=== Test 9: pair with no named args ==="
positional_only: {list "a", "b", "c"}
p_iter: {pair ~positional_only}
print "Pair on positional-only:", ~p_iter
print ""

print "=== Test 10: token_valid lifecycle ==="
gen3: {generator simple_gen}
print "Before resume:", {token_valid ~gen3}
x: {resume ~gen3}
print "After 1 resume:", {token_valid ~gen3}
x: {resume ~gen3}
x: {resume ~gen3}
x: {resume ~gen3}
print "After exhaust:", {token_valid ~gen3}
print ""

print "=== Test 11: while with token_valid ==="
macro range_gen (
    i: $1
    max: $2
    while (lt ~i, ~max), (
        yield ~i
        i: {add ~i, 1}
    )
    ret "range_done"
)

rg: {generator range_gen, 0, 5}
print "Range 0-4:"
while (token_valid ~rg), (
    v: {resume ~rg}
    print " ", ~v
)
print ""

print "=== Test 12: Multiple generators in sequence ==="
msleep 10
g1: {generator counter, 1, 3}
g2: {generator counter, 10, 13}
print "g1:", {resume ~g1}, {resume ~g1}
msleep 5
print "g2:", {resume ~g2}, {resume ~g2}, {resume ~g2}
print "g1 final:", {resume ~g1}
print ""

print "=== Test 13: Generator with msleep between resumes ==="
macro simple_three (
    yield "one"
    yield "two"
    yield "three"
    ret "three_done"
)

slow: {generator simple_three}
print "Slow 1:", {resume ~slow}
msleep 10
print "Slow 2:", {resume ~slow}
msleep 10
print "Slow 3:", {resume ~slow}
print "Slow 4:", {resume ~slow}
print ""

print "=== Test 14: Nested while loops in generator ==="
macro nested_while_gen (
    outer: 0
    while (lt ~outer, 2), (
        inner: 0
        while (lt ~inner, 2), (
            yield {list ~outer, ~inner}
            inner: {add ~inner, 1}
        )
        outer: {add ~outer, 1}
    )
    ret "nested_done"
)

nested: {generator nested_while_gen}
print "Nested pairs:"
while (token_valid ~nested), (
    p: {resume ~nested}
    print " ", ~p
)
print ""

print "=== Test 15: Generator consuming another generator ==="
macro double_gen (
    src: $1
    while (token_valid ~src), (
        v: {resume ~src}
        yield {mul ~v, 2}
    )
    ret "double_done"
)

base: {generator range_gen, 1, 4}
doubler: {generator double_gen, ~base}
print "Doubled values:"
print " ", {resume ~doubler}
print " ", {resume ~doubler}
print " ", {resume ~doubler}
print "After:", {resume ~doubler}
print ""

print "=== Test 16: each iterator with msleep ==="
items: {list "red", "green", "blue"}
it: {each ~items}
print "Colors with delay:"
msleep 5
while (token_valid ~it), (
    c: {resume ~it}
    print " -", ~c
    msleep 3
)
print ""

print "=== Test 17: Generator state isolation ==="
macro stateful_gen (
    counter: 0
    yield ~counter
    counter: {add ~counter, 10}
    yield ~counter
    counter: {add ~counter, 100}
    yield ~counter
    ret ~counter
)

s1: {generator stateful_gen}
s2: {generator stateful_gen}
print "s1:", {resume ~s1}
print "s2:", {resume ~s2}
print "s1:", {resume ~s1}
print "s2:", {resume ~s2}
print "s1:", {resume ~s1}
print "s2:", {resume ~s2}
print "s1 final:", {resume ~s1}
print "s2 final:", {resume ~s2}
print ""

print "=== Test 18: pair iterator on mixed list ==="
mixed: {list "positional1", "positional2", alpha: 1, beta: 2, gamma: 3}
print "Positional count:", {len ~mixed}
pi: {pair ~mixed}
print "Named pairs:"
while (token_valid ~pi), (
    kv: {resume ~pi}
    print " ", {argv ~kv, 1}, "->", {argv ~kv, 2}
)
print ""

print "=== Test 19: Generator with conditional yields ==="
macro conditional_gen (
    n: $1
    i: 0
    while (lt ~i, ~n), (
        # Only yield even numbers
        isEven: {eq {imodulo ~i, 2}, 0}
        if ~isEven then (
            yield ~i
        )
        i: {add ~i, 1}
    )
    ret "conditional_done"
)

cond: {generator conditional_gen, 8}
print "Even numbers 0-7:"
while (token_valid ~cond), (
    v: {resume ~cond}
    print " ", ~v
)
print ""

print "=== Test 20: Consuming generator with msleep delays ==="
macro basic_counter (
    i: 0
    max: $1
    while (lt ~i, ~max), (
        yield ~i
        i: {add ~i, 1}
    )
    ret "counter_done"
)

ac: {generator basic_counter, 4}
print "Async count with delays:"
while (token_valid ~ac), (
    msleep 5
    v: {resume ~ac}
    print " ", ~v
)
print ""

print "All generator tests passed!"
