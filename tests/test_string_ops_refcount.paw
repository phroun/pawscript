#!/usr/bin/env paw
# Test string operations with reference counting
# Tests both small (inline) and large (stored) strings

echo "=== String Operations Reference Counting Test ==="
echo ""

# Helper: create a large string (over 200 chars)
large_base: "This is a very large string that exceeds the 200 character threshold for automatic storage. It contains enough text to trigger the storage mechanism which will convert it into a stored object with a reference marker."

echo "Test 1: Initial state"
mem_stats
echo "Expected: 0 objects"
echo ""

# ============ upper ============
echo "Test 2: upper with small string"
small_upper: {upper "hello world"}
mem_stats
echo "Expected: 0 objects (small string stays inline)"
echo ""

echo "Test 3: upper with large string"
large_upper: {upper ~large_base}
mem_stats
echo "Expected: 2 objects (large_base + large_upper)"
echo ""

echo "Test 4: Clear upper results"
small_upper: nil
large_upper: nil
mem_stats
echo "Expected: 1 object (only large_base)"
echo ""

# ============ lower ============
echo "Test 5: lower with small string"
small_lower: {lower "HELLO WORLD"}
mem_stats
echo "Expected: 1 object (large_base)"
echo ""

echo "Test 6: lower with large string"
large_lower: {lower ~large_base}
mem_stats
echo "Expected: 2 objects (large_base + large_lower)"
echo ""

echo "Test 7: Clear lower results"
small_lower: nil
large_lower: nil
mem_stats
echo "Expected: 1 object (only large_base)"
echo ""

# ============ trim ============
echo "Test 8: trim with small string"
small_trim: {trim "  hello  "}
mem_stats
echo "Expected: 1 object (large_base)"
echo ""

echo "Test 9: trim with large string"
padded_large: "   ~large_base   "
large_trim: {trim ~padded_large}
mem_stats
echo "Expected: 3 objects (large_base + padded_large + large_trim)"
echo ""

echo "Test 10: Clear trim results"
small_trim: nil
padded_large: nil
large_trim: nil
mem_stats
echo "Expected: 1 object (only large_base)"
echo ""

# ============ trim_start ============
echo "Test 11: trim_start with small string"
small_trim_start: {trim_start "  hello  "}
mem_stats
echo "Expected: 1 object (large_base)"
echo ""

echo "Test 12: Clear trim_start result"
small_trim_start: nil
mem_stats
echo "Expected: 1 object (large_base)"
echo ""

# ============ trim_end ============
echo "Test 13: trim_end with small string"
small_trim_end: {trim_end "  hello  "}
mem_stats
echo "Expected: 1 object (large_base)"
echo ""

echo "Test 14: Clear trim_end result"
small_trim_end: nil
mem_stats
echo "Expected: 1 object (large_base)"
echo ""

# ============ replace ============
echo "Test 15: replace with small string"
small_replace: {replace "hello world", "world", "there"}
mem_stats
echo "Expected: 1 object (large_base)"
echo ""

echo "Test 16: replace with large string"
large_replace: {replace ~large_base, "string", "STRING"}
mem_stats
echo "Expected: 2 objects (large_base + large_replace)"
echo ""

echo "Test 17: Clear replace results"
small_replace: nil
large_replace: nil
mem_stats
echo "Expected: 1 object (only large_base)"
echo ""

# ============ repeat ============
echo "Test 18: repeat small result"
small_repeat: {repeat "ab", 3}
mem_stats
echo "Expected: 1 object (large_base)"
echo ""

echo "Test 19: repeat large result"
large_repeat: {repeat "abcdefghij", 25}
mem_stats
echo "Expected: 2 objects (large_base + large_repeat of 250 chars)"
echo ""

echo "Test 20: Clear repeat results"
small_repeat: nil
large_repeat: nil
mem_stats
echo "Expected: 1 object (only large_base)"
echo ""

# ============ slice (string) ============
echo "Test 21: slice small result from large string"
small_slice: {slice ~large_base, 0, 10}
mem_stats
echo "Expected: 1 object (large_base, slice is small)"
echo ""

echo "Test 22: slice large result from large string"
large_slice: {slice ~large_base, 0, 205}
mem_stats
echo "Expected: 2 objects (large_base + large_slice)"
echo ""

echo "Test 23: Clear slice results"
small_slice: nil
large_slice: nil
mem_stats
echo "Expected: 1 object (only large_base)"
echo ""

# ============ str_join ============
echo "Test 24: join small result"
items: {list a, b, c}
small_join: {join ~items, ", "}
mem_stats
echo "Expected: 2 objects (large_base + items list)"
echo ""

echo "Test 25: join large result"
big_items: {list ~large_base, ~large_base}
large_join: {join ~big_items, " | "}
mem_stats
echo "Expected: 4 objects (large_base + items + big_items + large_join)"
echo ""

echo "Test 26: Clear join results"
items: nil
small_join: nil
big_items: nil
large_join: nil
mem_stats
echo "Expected: 1 object (only large_base)"
echo ""

# ============ exec ============
# Select helper based on OS
(os:): ~#args
if {eq ~os, "windows"} then echo_helper: "helpers/echo.bat" else echo_helper: "helpers/echo.sh"

echo "Test 27: exec with small output"
small_exec: {exec ~echo_helper, "hello"}
mem_stats
echo "Expected: 1 object (large_base)"
echo ""

echo "Test 28: exec with large output"
large_exec: {exec ~echo_helper, ~large_base}
mem_stats
echo "Expected: 2 objects (large_base + large_exec)"
echo ""

echo "Test 29: Clear exec results"
small_exec: nil
large_exec: nil
mem_stats
echo "Expected: 1 object (only large_base)"
echo ""

# ============ Final cleanup ============
echo "Test 30: Clear large_base"
large_base: nil
mem_stats
echo "Expected: 0 objects (all freed)"
echo ""

echo "=== Test Complete ==="
